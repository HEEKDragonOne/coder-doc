## 列表和数组

::: tip

- Polars 有两种容器数据类型, 列表（`List`）和数组（`Array`），两者有很多类似的功能。
- [官方API-List](https://docs.pola.rs/api/python/stable/reference/api/polars.datatypes.List.html)
- [官方API-Array](https://docs.pola.rs/api/python/stable/reference/api/polars.datatypes.Array.html)

:::


### 列表`List`

`List`: 存放同一数据类型的`一维`容器，长度可变。

```python title="Python"
from datetime import datetime

df = pl.DataFrame(
    {
        "names": [
            ["Anne", "Averill", "Adams"],
            ["Brandon", "Brooke", "Borden", "Branson"],
            ["Camila", "Campbell"],
            ["Dennis", "Doyle"],
        ],
        "children_ages": [
            [5, 7],
            [],
            [],
            [8, 11, 18],
        ],
        "medical_appointments": [
            [],
            [],
            [],
            [datetime(2022, 5, 22, 16, 30)],
        ],
    }
)

print(df)
```

```text
shape: (4, 3)
┌─────────────────────────────────┬───────────────┬───────────────────────┐
│ names                           ┆ children_ages ┆ medical_appointments  │
│ ---                             ┆ ---           ┆ ---                   │
│ list[str]                       ┆ list[i64]     ┆ list[datetime[μs]]    │
╞═════════════════════════════════╪═══════════════╪═══════════════════════╡
│ ["Anne", "Averill", "Adams"]    ┆ [5, 7]        ┆ []                    │
│ ["Brandon", "Brooke", … "Brans… ┆ []            ┆ []                    │
│ ["Camila", "Campbell"]          ┆ []            ┆ []                    │
│ ["Dennis", "Doyle"]             ┆ [8, 11, 18]   ┆ [2022-05-22 16:30:00] │
└─────────────────────────────────┴───────────────┴───────────────────────┘
```

:::note

数据类型`List`与Python的`list`不同。

:::

### 数组`Array`

`Array`: 存放同一数据类型的`多维`容器，长度固定。所以适合于已知大小和数据类型的数据存储。

下面代码中, 一共两列, 对于每一列来说, 要求每行的元素长度相同, 数据元素类型相同
```python title="Python"
df = pl.DataFrame(
    {
        "bit_flags": [
            [True, True, True, True, False],
            [False, True, True, True, True],
        ],
        "tic_tac_toe": [
            [
                [" ", "x", "o"],
                [" ", "x", " "],
                ["o", "x", " "],
            ],
            [
                ["o", "x", "x"],
                [" ", "o", "x"],
                [" ", " ", "o"],
            ],
        ],
    },
    schema={
        "bit_flags": pl.Array(pl.Boolean, 5),
        "tic_tac_toe": pl.Array(pl.String, (3, 3)),
    },
)

print(df)
```

```text
shape: (2, 2)
┌───────────────────────┬─────────────────────────────────┐
│ bit_flags             ┆ tic_tac_toe                     │
│ ---                   ┆ ---                             │
│ array[bool, 5]        ┆ array[str, (3, 3)]              │
╞═══════════════════════╪═════════════════════════════════╡
│ [true, true, … false] ┆ [[" ", "x", "o"], [" ", "x", "… │
│ [false, true, … true] ┆ [["o", "x", "x"], [" ", "o", "… │
└───────────────────────┴─────────────────────────────────┘
```

上面示例中，通过`schema`参数显式的指定了`bit_flags`是一维`Boolean`类型的数组,`tic_tac_toe`是三行三列的二维String类型数组。因为通常情况下，出于性能原因， Polars 默认使用`List`，而不是使用`Array`。如下所示：

```python title="Python"
df = pl.DataFrame(
    {
        "bit_flags": [
            [True, True, True, True, False],
            [False, True, True, True, True],
        ],
        "tic_tac_toe": [
            [
                [" ", "x", "o"],
                [" ", "x", " "],
                ["o", "x", " "],
            ],
            [
                ["o", "x", "x"],
                [" ", "o", "x"],
                [" ", " ", "o"],
            ],
        ],
    }
)

print(df)
```

```text
shape: (2, 2)
┌───────────────────────┬─────────────────────────────────┐
│ bit_flags             ┆ tic_tac_toe                     │
│ ---                   ┆ ---                             │
│ list[bool]            ┆ list[list[str]]                 │
╞═══════════════════════╪═════════════════════════════════╡
│ [true, true, … false] ┆ [[" ", "x", "o"], [" ", "x", "… │
│ [false, true, … true] ┆ [["o", "x", "x"], [" ", "o", "… │
└───────────────────────┴─────────────────────────────────┘
```

但是，有一个特例。就是当用 NumPy 数组来构建列时：


```python title="Python"
import numpy as np

array = np.arange(0, 120).reshape((5, 2, 3, 4))  # 4D array

print(pl.Series(array).dtype)  # Column with the 3D subarrays
```

```text
Array(Int64, shape=(2, 3, 4))
```

## 使用`List`

### 数据准备
Polars提供了很多函数去处理`List`数据类型, 这些函数在命名空间`list`中。如下是一个不同气象站的天气数据：

```python title="Python"
weather = pl.DataFrame(
    {
        "station": [f"Station {idx}" for idx in range(1, 6)],
        "temperatures": [
            "20 5 5 E1 7 13 19 9 6 20",
            "18 8 16 11 23 E2 8 E2 E2 E2 90 70 40",
            "19 24 E9 16 6 12 10 22",
            "E2 E0 15 7 8 10 E1 24 17 13 6",
            "14 8 E0 16 22 24 E1",
        ],
    }
)

print(weather)
```
```text
shape: (5, 2)
┌───────────┬─────────────────────────────────┐
│ station   ┆ temperatures                    │
│ ---       ┆ ---                             │
│ str       ┆ str                             │
╞═══════════╪═════════════════════════════════╡
│ Station 1 ┆ 20 5 5 E1 7 13 19 9 6 20        │
│ Station 2 ┆ 18 8 16 11 23 E2 8 E2 E2 E2 90… │
│ Station 3 ┆ 19 24 E9 16 6 12 10 22          │
│ Station 4 ┆ E2 E0 15 7 8 10 E1 24 17 13 6   │
│ Station 5 ┆ 14 8 E0 16 22 24 E1             │
└───────────┴─────────────────────────────────┘
```

对于上面的示例数据，当想对每个站点捕获的温度进行分析时, 需要先把`temperatures`这一列中的每一行按照空格进行分割成列表：
```python title="Python"
weather = weather.with_columns(
    pl.col("temperatures").str.split(" "),
)
print(weather)
```

```text
shape: (5, 2)
┌───────────┬──────────────────────┐
│ station   ┆ temperatures         │
│ ---       ┆ ---                  │
│ str       ┆ list[str]            │
╞═══════════╪══════════════════════╡
│ Station 1 ┆ ["20", "5", … "20"]  │
│ Station 2 ┆ ["18", "8", … "40"]  │
│ Station 3 ┆ ["19", "24", … "22"] │
│ Station 4 ┆ ["E2", "E0", … "6"]  │
│ Station 5 ┆ ["14", "8", … "E1"]  │
└───────────┴──────────────────────┘
```

### 操作列表

Polars在命名空间`list`中提供了很多操作列表的函数, 包括和之前处理字符串一样类似功能的`slice`、 `head`、 `tail`等函数。

```python title="Python"
result = weather.with_columns(
    pl.col("temperatures").list.head(3).alias("head"), # 获取列表中的前3个元素
    pl.col("temperatures").list.tail(3).alias("tail"), # 获取列表中的后3个元素
    pl.col("temperatures").list.slice(-3, 2).alias("two_next_to_last"), # 从列表倒数第3个开始，连续获取两个元素
)
print(result)
```
```text
shape: (5, 5)
┌───────────┬──────────────────────┬────────────────────┬────────────────────┬──────────────────┐
│ station   ┆ temperatures         ┆ head               ┆ tail               ┆ two_next_to_last │
│ ---       ┆ ---                  ┆ ---                ┆ ---                ┆ ---              │
│ str       ┆ list[str]            ┆ list[str]          ┆ list[str]          ┆ list[str]        │
╞═══════════╪══════════════════════╪════════════════════╪════════════════════╪══════════════════╡
│ Station 1 ┆ ["20", "5", … "20"]  ┆ ["20", "5", "5"]   ┆ ["9", "6", "20"]   ┆ ["9", "6"]       │
│ Station 2 ┆ ["18", "8", … "40"]  ┆ ["18", "8", "16"]  ┆ ["90", "70", "40"] ┆ ["90", "70"]     │
│ Station 3 ┆ ["19", "24", … "22"] ┆ ["19", "24", "E9"] ┆ ["12", "10", "22"] ┆ ["12", "10"]     │
│ Station 4 ┆ ["E2", "E0", … "6"]  ┆ ["E2", "E0", "15"] ┆ ["17", "13", "6"]  ┆ ["17", "13"]     │
│ Station 5 ┆ ["14", "8", … "E1"]  ┆ ["14", "8", "E0"]  ┆ ["22", "24", "E1"] ┆ ["22", "24"]     │
└───────────┴──────────────────────┴────────────────────┴────────────────────┴──────────────────┘
```


### 列表遍历

:::tip 遐想

- Python：.apply(lambda x: (x.rate + 1))
- Java：.forEach(x -> x.rate + 1)

:::

通过`list`命名空间中的`eval`和`element`配合, 可以实现对列表中的每个元素执行操作:

```python title="Python"
result = weather.with_columns(
    (pl.col("temperatures").list.eval(pl.element().str.contains("E"))).alias("flag"),
)

print(result)
```

```text
shape: (5, 3)
┌───────────┬──────────────────────┬─────────────────────────┐
│ station   ┆ temperatures         ┆ flag                    │
│ ---       ┆ ---                  ┆ ---                     │
│ str       ┆ list[str]            ┆ list[bool]              │
╞═══════════╪══════════════════════╪═════════════════════════╡
│ Station 1 ┆ ["20", "5", … "20"]  ┆ [false, false, … false] │
│ Station 2 ┆ ["18", "8", … "40"]  ┆ [false, false, … false] │
│ Station 3 ┆ ["19", "24", … "22"] ┆ [false, false, … false] │
│ Station 4 ┆ ["E2", "E0", … "6"]  ┆ [true, true, … false]   │
│ Station 5 ┆ ["14", "8", … "E1"]  ┆ [false, false, … true]  │
└───────────┴──────────────────────┴─────────────────────────┘
```


### 统计列表

找出每个站点的气温异常的次数:
- 将测量结果转化为数字, 异常气温的会变为`null`。（或者直接简单判断是否有字母E）
- 统计列表中null的数量
- 将此列输出重命名为"error"


```python title="Python"
result = weather.with_columns(
    pl.col("temperatures")  # 选中temperatures这一列
    .list  # 获取命名空间 list
    .eval(  # 使用eval方法, 针对列表中的每个元素进行操作
        pl.element()  # 获取列表中的元素
        .cast(pl.Int64, strict=False)  # 转换为数字, 失败的会变为null
        .is_null()  # 获取是否为null
    )
    .list.sum()  # 对列表中的元素求和, True为1, False为0
    .alias("errors"),
)
print(result)
```

```text
shape: (5, 3)
┌───────────┬──────────────────────┬────────┐
│ station   ┆ temperatures         ┆ errors │
│ ---       ┆ ---                  ┆ ---    │
│ str       ┆ list[str]            ┆ u32    │
╞═══════════╪══════════════════════╪════════╡
│ Station 1 ┆ ["20", "5", … "20"]  ┆ 1      │
│ Station 2 ┆ ["18", "8", … "40"]  ┆ 4      │
│ Station 3 ┆ ["19", "24", … "22"] ┆ 1      │
│ Station 4 ┆ ["E2", "E0", … "6"]  ┆ 3      │
│ Station 5 ┆ ["14", "8", … "E1"]  ┆ 2      │
└───────────┴──────────────────────┴────────┘
```

### 逐行计算

创建新数据集：
```python title="Python"
weather_by_day = pl.DataFrame(
    {
        "station": [f"Station {idx}" for idx in range(1, 11)],
        "day_1": [17, 11, 8, 22, 9, 21, 20, 8, 8, 17],
        "day_2": [15, 11, 10, 8, 7, 14, 18, 21, 15, 13],
        "day_3": [16, 15, 24, 24, 8, 23, 19, 23, 16, 10],
    }
)
print(weather_by_day)
```
```text
shape: (10, 4)
┌────────────┬───────┬───────┬───────┐
│ station    ┆ day_1 ┆ day_2 ┆ day_3 │
│ ---        ┆ ---   ┆ ---   ┆ ---   │
│ str        ┆ i64   ┆ i64   ┆ i64   │
╞════════════╪═══════╪═══════╪═══════╡
│ Station 1  ┆ 17    ┆ 15    ┆ 16    │
│ Station 2  ┆ 11    ┆ 11    ┆ 15    │
│ Station 3  ┆ 8     ┆ 10    ┆ 24    │
│ Station 4  ┆ 22    ┆ 8     ┆ 24    │
│ Station 5  ┆ 9     ┆ 7     ┆ 8     │
│ Station 6  ┆ 21    ┆ 14    ┆ 23    │
│ Station 7  ┆ 20    ┆ 18    ┆ 19    │
│ Station 8  ┆ 8     ┆ 21    ┆ 23    │
│ Station 9  ┆ 8     ┆ 15    ┆ 16    │
│ Station 10 ┆ 17    ┆ 13    ┆ 10    │
└────────────┴───────┴───────┴───────┘
```

现在计算各个站点每日温度的百分比排名：

```python title="Python"
rank_pct = (pl.element().rank(descending=True) / pl.element().count()).round(2)

result = weather_by_day.with_columns(
    # concat_list将每一行中的所有元素合并成一个列表, 用于生成一个临时的中间列 "all_temps"
    pl.concat_list(pl.all().exclude("station")).alias("all_temps")
).select(
    # 选择除了 all_temps 这一列之外的所有列
    pl.all().exclude("all_temps"),
    pl.col("all_temps").list.eval(rank_pct, parallel=True).alias("temps_rank"),
)

print(result)
```
```text
shape: (10, 5)
┌────────────┬───────┬───────┬───────┬────────────────────┐
│ station    ┆ day_1 ┆ day_2 ┆ day_3 ┆ temps_rank         │
│ ---        ┆ ---   ┆ ---   ┆ ---   ┆ ---                │
│ str        ┆ i64   ┆ i64   ┆ i64   ┆ list[f64]          │
╞════════════╪═══════╪═══════╪═══════╪════════════════════╡
│ Station 1  ┆ 17    ┆ 15    ┆ 16    ┆ [0.33, 1.0, 0.67]  │
│ Station 2  ┆ 11    ┆ 11    ┆ 15    ┆ [0.83, 0.83, 0.33] │
│ Station 3  ┆ 8     ┆ 10    ┆ 24    ┆ [1.0, 0.67, 0.33]  │
│ Station 4  ┆ 22    ┆ 8     ┆ 24    ┆ [0.67, 1.0, 0.33]  │
│ Station 5  ┆ 9     ┆ 7     ┆ 8     ┆ [0.33, 1.0, 0.67]  │
│ Station 6  ┆ 21    ┆ 14    ┆ 23    ┆ [0.67, 1.0, 0.33]  │
│ Station 7  ┆ 20    ┆ 18    ┆ 19    ┆ [0.33, 1.0, 0.67]  │
│ Station 8  ┆ 8     ┆ 21    ┆ 23    ┆ [1.0, 0.67, 0.33]  │
│ Station 9  ┆ 8     ┆ 15    ┆ 16    ┆ [1.0, 0.67, 0.33]  │
│ Station 10 ┆ 17    ┆ 13    ┆ 10    ┆ [0.33, 0.67, 1.0]  │
└────────────┴───────┴───────┴───────┴────────────────────┘
```

## 使用 `Array`

Polars通常不会对Array做类型推导, 所以必须在创建`Series`/`DataFrame`是显式指定数据类型, 或者使用 NumPy 数组创建该列。

```python
df = pl.DataFrame(
    {
        "first_last": [
            ["Anne", "Adams"],
            ["Brandon", "Branson"],
            ["Camila", "Campbell"],
            ["Dennis", "Doyle"],
        ],
        "fav_numbers": [
            [42, 0, 1],
            [2, 3, 5],
            [13, 21, 34],
            [73, 3, 7],
        ],
    },
    schema={
        "first_last": pl.Array(pl.String, 2),
        "fav_numbers": pl.Array(pl.Int32, 3),
    },
)

result = df.select(
    pl.col("first_last").arr.join(" ").alias("name"),
    pl.col("fav_numbers").arr.sort(),
    pl.col("fav_numbers").arr.max().alias("largest_fav"),
    pl.col("fav_numbers").arr.sum().alias("summed"),
    pl.col("fav_numbers").arr.contains(3).alias("likes_3"),
)
print(result)
```

```text
shape: (4, 5)
┌─────────────────┬───────────────┬─────────────┬────────┬─────────┐
│ name            ┆ fav_numbers   ┆ largest_fav ┆ summed ┆ likes_3 │
│ ---             ┆ ---           ┆ ---         ┆ ---    ┆ ---     │
│ str             ┆ array[i32, 3] ┆ i32         ┆ i32    ┆ bool    │
╞═════════════════╪═══════════════╪═════════════╪════════╪═════════╡
│ Anne Adams      ┆ [0, 1, 42]    ┆ 42          ┆ 43     ┆ false   │
│ Brandon Branson ┆ [2, 3, 5]     ┆ 5           ┆ 10     ┆ true    │
│ Camila Campbell ┆ [13, 21, 34]  ┆ 34          ┆ 68     ┆ false   │
│ Dennis Doyle    ┆ [3, 7, 73]    ┆ 73          ┆ 83     ┆ true    │
└─────────────────┴───────────────┴─────────────┴────────┴─────────┘
```